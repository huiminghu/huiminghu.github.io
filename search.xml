<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>抽象工厂模式</title>
      <link href="/2021/12/30/she-ji-mo-shi/chou-xiang-gong-han-mo-shi/"/>
      <url>/2021/12/30/she-ji-mo-shi/chou-xiang-gong-han-mo-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="一、抽象工厂模式概述"><a href="#一、抽象工厂模式概述" class="headerlink" title="一、抽象工厂模式概述"></a>一、抽象工厂模式概述</h2><p>工厂方法模式考虑的是一类产品的生产，如畜牧场只养动物、电视机厂只生产电视机、计算机软件学院只培养计算机软件专业的学生等。</p><p>同种类称为同等级，也就是说：工厂方法模式只考虑生产<strong>同等级</strong>的产品，但是在现实生活中许多工厂是综合型的工厂，能生产多等级（种类） 的产品，如农场里既养动物又种植物，电器厂既生产电视机又生产洗衣机或空调，大学既有软件专业又有生物专业等。</p><p>抽象工厂模式考虑<strong>多等级</strong>产品的生产，将同一个具体工厂所生产的位于不同等级的一组产品称为一个<strong>产品族</strong>。</p><h2 id="二、抽象工厂模式的定义"><a href="#二、抽象工厂模式的定义" class="headerlink" title="二、抽象工厂模式的定义"></a>二、抽象工厂模式的定义</h2><p>抽象工厂（AbstractFactory）模式的定义：是一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构。</p><p>抽象工厂模式是工厂方法模式的升级版本，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品。</p><p>使用抽象工厂模式一般要满足以下条件。<br>系统中有多个产品族，每个具体工厂创建同一族但属于不同等级结构的产品。<br>系统一次只可能消费其中某一族产品，即同族的产品一起使用。</p><h2 id="三、抽象工厂模式的优点和缺点"><a href="#三、抽象工厂模式的优点和缺点" class="headerlink" title="三、抽象工厂模式的优点和缺点"></a>三、抽象工厂模式的优点和缺点</h2><p>优点：</p><ul><li>可以在类的内部对产品族中相关联的多等级产品共同管理，而不必专门引入多个新的类来进行管理。</li><li>当需要产品族时，抽象工厂可以保证客户端始终只使用同一个产品的产品组。</li><li>抽象工厂增强了程序的可扩展性，当增加一个新的产品族时，不需要修改原代码，满足开闭原则。</li></ul><p>缺点：</p><ul><li>当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。增加了系统的抽象性和理解难度。</li></ul><h2 id="四、抽象工厂模式的应用场景"><a href="#四、抽象工厂模式的应用场景" class="headerlink" title="四、抽象工厂模式的应用场景"></a>四、抽象工厂模式的应用场景</h2><p>抽象工厂模式通常适用于以下场景：</p><ul><li>当需要创建的对象是一系列相互关联或相互依赖的产品族时，如电器工厂中的电视机、洗衣机、空调等。</li><li>系统中有多个产品族，但每次只使用其中的某一族产品。如有人只喜欢穿某一个品牌的衣服和鞋。</li><li>系统中提供了产品的类库，且所有产品的接口相同，客户端不依赖产品实例的创建细节和内部结构。</li></ul><h2 id="五、抽象工厂模式的结构与实现"><a href="#五、抽象工厂模式的结构与实现" class="headerlink" title="五、抽象工厂模式的结构与实现"></a>五、抽象工厂模式的结构与实现</h2><p>抽象工厂模式同工厂方法模式一样，也是由抽象工厂、具体工厂、抽象产品和具体产品等 4 个要素构成，但抽象工厂中方法个数不同，抽象产品的个数也不同。</p><h3 id="1-抽象工厂模式的结构"><a href="#1-抽象工厂模式的结构" class="headerlink" title="1. 抽象工厂模式的结构"></a>1. 抽象工厂模式的结构</h3><p>抽象工厂模式的主要角色如下：</p><ul><li>抽象工厂（Abstract Factory）：提供了创建产品的接口，它包含多个创建产品的方法 newProduct()，可以创建多个不同等级的产品。</li><li>具体工厂（Concrete Factory）：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。</li><li>抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。</li><li>具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间是多对一的关系。</li></ul><h3 id="2-抽象工厂模式的实现"><a href="#2-抽象工厂模式的实现" class="headerlink" title="2. 抽象工厂模式的实现"></a>2. 抽象工厂模式的实现</h3><p>抽象工厂模式的结构同工厂方法模式的结构相似，不同的是其产品的种类不止一个，所以创建产品的方法也不止一个。</p><pre><code>interface AbstractFactory {    public Product1 newProduct1();    public Product2 newProduct2();}class ConcreteFactory1 implements AbstractFactory {    public Product1 newProduct1() {        System.out.println(&quot;具体工厂 1 生成--&gt;具体产品 11...&quot;);        return new ConcreteProduct11();    }    public Product2 newProduct2() {        System.out.println(&quot;具体工厂 1 生成--&gt;具体产品 21...&quot;);        return new ConcreteProduct21();    }}</code></pre><h2 id="六、抽象工厂模式的实际应用"><a href="#六、抽象工厂模式的实际应用" class="headerlink" title="六、抽象工厂模式的实际应用"></a>六、抽象工厂模式的实际应用</h2><h4 id="1-抽象工厂模式在Java源码中的应用"><a href="#1-抽象工厂模式在Java源码中的应用" class="headerlink" title="1. 抽象工厂模式在Java源码中的应用"></a>1. 抽象工厂模式在Java源码中的应用</h4><p>java.sql.Connection接口是一个经典的抽象工厂，而 Statement、PreparedStatement、CallableStatement 是 Connection 这个抽象工厂中提供的三个抽象产品，源码如下所示：</p><pre><code>public interface Connection {    //提供一个执行对象    Statement createStatement() throws SQLException;    //提供一个支持预编译的执行对象    PreparedStatement prepareStatement(String sql) throws SQLException;    //提供一个支持存储过程的执行对象    CallableStatement prepareCall(String sql) throws SQLException;}</code></pre><h4 id="2-抽象工厂模式在Spring源码中的应用"><a href="#2-抽象工厂模式在Spring源码中的应用" class="headerlink" title="2. 抽象工厂模式在Spring源码中的应用"></a>2. 抽象工厂模式在Spring源码中的应用</h4><p>在 Spring 中，BeanFactory 是用于管理 Bean 的一个工厂，所有工厂都是 BeanFactory 的子类。这样我们可以通过 IOC 容器来管理访问 Bean，根据不同的策略调用 getBean() 方法，从而获得具体对象。<br>BeanFactory 接口的源码如下：</p><pre><code>public interface BeanFactory {    String FACTORY_BEAN_PREFIX = &quot;&amp;&quot;;    Object getBean(String name) throws BeansException;    &lt;T&gt; T getBean(String name, @Nullable Class&lt;T&gt; requiredType) throws BeansException;    Object getBean(String name, Object... args) throws BeansException;    &lt;T&gt; T getBean(Class&lt;T&gt; requiredType) throws BeansException;    &lt;T&gt; T getBean(Class&lt;T&gt; requiredType, Object... args) throws BeansException;    boolean containsBean(String name);    boolean isSingleton(String name) throws NoSuchBeanDefinitionException;    boolean isPrototype(String name) throws NoSuchBeanDefinitionException;    boolean isTypeMatch(String name, ResolvableType typeToMatch) throws NoSuchBeanDefinitionException;    boolean isTypeMatch(String name, @Nullable Class&lt;?&gt; typeToMatch) throws NoSuchBeanDefinitionException;    Class&lt;?&gt; getType(String name) throws NoSuchBeanDefinitionException;    String[] getAliases(String name);}</code></pre><p>BeanFactory 的子类主要有 ClassPathXmlApplicationContext、XmlWebApplicationContext、StaticWebApplicationContext、StaticApplicationContext。在 Spring 中，DefaultListableBeanFactory 实现了所有工厂的公共逻辑。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工厂方法模式</title>
      <link href="/2021/12/29/she-ji-mo-shi/gong-han-fang-fa-mo-shi/"/>
      <url>/2021/12/29/she-ji-mo-shi/gong-han-fang-fa-mo-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="一、工厂方法模式概述"><a href="#一、工厂方法模式概述" class="headerlink" title="一、工厂方法模式概述"></a>一、工厂方法模式概述</h2><p>在现实生活中社会分工越来越细，越来越专业化。各种产品有专门的工厂生产，彻底告别了自给自足的小农经济时代，这大大缩短了产品的生产周期，提高了生产效率。同样，在软件开发中能否做到软件对象的生产和使用相分离呢？能否在满足“开闭原则”的前提下，客户随意增删或改变对软件相关对象的使用呢？</p><p>简单工厂模式违背了开闭原则，而“工厂方法模式”是对简单工厂模式的进一步抽象化，其好处是可以使系统在不修改原来代码的情况下引进新的产品，即满足开闭原则。</p><h2 id="二、工厂方法模式的优点和缺点"><a href="#二、工厂方法模式的优点和缺点" class="headerlink" title="二、工厂方法模式的优点和缺点"></a>二、工厂方法模式的优点和缺点</h2><p>优点：</p><ul><li>用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程。</li><li>灵活性增强，对于新产品的创建，只需多写一个相应的工厂类。</li><li>典型的解耦框架。高层模块只需要知道产品的抽象类，无须关心其他实现类，满足迪米特法则、依赖倒置原则和里氏替换原则。</li></ul><p>缺点：</p><ul><li>类的个数容易过多，增加复杂度。</li><li>增加了系统的抽象性和理解难度。</li><li>抽象产品只能生产一种产品，此弊端可使用抽象工厂模式解决。</li></ul><h2 id="三、工厂方法模式的应用场景"><a href="#三、工厂方法模式的应用场景" class="headerlink" title="三、工厂方法模式的应用场景"></a>三、工厂方法模式的应用场景</h2><ul><li>客户只知道创建产品的工厂名，而不知道具体的产品名。如 TCL 电视工厂、海信电视工厂等。</li><li>创建对象的任务由多个具体子工厂中的某一个完成，而抽象工厂只提供创建产品的接口。</li><li>客户不关心创建产品的细节，只关心产品的品牌。</li></ul><h2 id="四、工厂方法模式的结构与实现"><a href="#四、工厂方法模式的结构与实现" class="headerlink" title="四、工厂方法模式的结构与实现"></a>四、工厂方法模式的结构与实现</h2><h3 id="1-工厂方法模式的结构"><a href="#1-工厂方法模式的结构" class="headerlink" title="1. 工厂方法模式的结构"></a>1. 工厂方法模式的结构</h3><p>工厂方法模式的主要角色如下：</p><ul><li>抽象工厂（Abstract Factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法 newProduct() 来创建产品。</li><li>具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。</li><li>抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能。</li><li>具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。</li></ul><h3 id="2-工厂方法模式的实现"><a href="#2-工厂方法模式的实现" class="headerlink" title="2. 工厂方法模式的实现"></a>2. 工厂方法模式的实现</h3><pre><code>public class AbstractFactoryTest {    public static void main(String[] args) {        try {            Product a;            AbstractFactory af;            af = (AbstractFactory) ReadXML1.getObject();            a = af.newProduct();            a.show();        } catch (Exception e) {            System.out.println(e.getMessage());        }    }}//抽象产品：提供了产品的接口interface Product {    public void show();}//具体产品1：实现抽象产品中的抽象方法class ConcreteProduct1 implements Product {    public void show() {        System.out.println(&quot;具体产品1显示...&quot;);    }}//具体产品2：实现抽象产品中的抽象方法class ConcreteProduct2 implements Product {    public void show() {        System.out.println(&quot;具体产品2显示...&quot;);    }}//抽象工厂：提供了厂品的生成方法interface AbstractFactory {    public Product newProduct();}//具体工厂1：实现了厂品的生成方法class ConcreteFactory1 implements AbstractFactory {    public Product newProduct() {        System.out.println(&quot;具体工厂1生成--&gt;具体产品1...&quot;);        return new ConcreteProduct1();    }}//具体工厂2：实现了厂品的生成方法class ConcreteFactory2 implements AbstractFactory {    public Product newProduct() {        System.out.println(&quot;具体工厂2生成--&gt;具体产品2...&quot;);        return new ConcreteProduct2();    }}</code></pre><h2 id="五、工厂方法模式的实际应用"><a href="#五、工厂方法模式的实际应用" class="headerlink" title="五、工厂方法模式的实际应用"></a>五、工厂方法模式的实际应用</h2><h4 id="1-工厂方法模式在Logback源码中的应用"><a href="#1-工厂方法模式在Logback源码中的应用" class="headerlink" title="1. 工厂方法模式在Logback源码中的应用"></a>1. 工厂方法模式在Logback源码中的应用</h4><p>在 Log 类中，抽象产品基类就是 Log，其中一个产品实现类为 LoggerLog，抽象工厂类为 LogFactory，工厂实现类为 LoggerLogFactory。另一个是 LogStreamLog 和 LogStreamLogFactory。其中关键代码如下:</p><pre><code>public abstract class Log {    ... ...    public abstract void log(Level var1, String var2);    private interface LogFactory {        Log createLog(String var1, String var2, Level var3);    }    private static class LoggerLog extends Log {        public void log(Level var1, String var2) {            if (this.isLoggable(var1)) {                String[] var3 = Log.getSource();                this.logger.logp(var1, var3[0], var3[1], Thread.currentThread().getName() + &quot;: &quot; + var2);            }        }    }    private static class LoggerLogFactory implements Log.LogFactory {        public Log createLog(String var1, String var2, Level var3) {            Logger var4 = Logger.getLogger(var1);            return new Log.LoggerLog(var4, var3);        }    }    private static class LogStreamLog extends Log {        public void log(Level var1, String var2) {            if (this.isLoggable(var1)) {                String[] var3 = Log.getSource();                this.stream.println(unqualifiedName(var3[0]) + &quot;.&quot; + var3[1] + &quot;: &quot; + var2);            }        }    }    private static class LogStreamLogFactory implements Log.LogFactory {        public Log createLog(String var1, String var2, Level var3) {            LogStream var4 = null;            if (var2 != null) {                var4 = LogStream.log(var2);            }            return new Log.LogStreamLog(var4, var3);        }    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单工厂模式</title>
      <link href="/2021/12/28/she-ji-mo-shi/jian-dan-gong-han-mo-shi/"/>
      <url>/2021/12/28/she-ji-mo-shi/jian-dan-gong-han-mo-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="一、工厂模式概述"><a href="#一、工厂模式概述" class="headerlink" title="一、工厂模式概述"></a>一、工厂模式概述</h2><p>现实生活中，原始社会自给自足（没有工厂），<strong>农耕社会小作坊</strong>（<strong>简单工厂</strong>，民间酒坊），<strong>工业革命流水线</strong>（<strong>工厂方法</strong>，自产自销），<strong>现代产业链代工厂</strong>（<strong>抽象工厂</strong>，富士康）。我们的项目代码同样是由简到繁一步一步迭代而来的，但对于调用者来说，却越来越简单。</p><p>在日常开发中，凡是需要生成<strong>复杂对象</strong>的地方，都可以尝试考虑使用工厂模式来代替。</p><blockquote><p>注意：上述复杂对象指的是类的构造函数参数过多等对类的构造有影响的情况，因为类的构造过于复杂，如果直接在其他业务类内使用，则两者的耦合过重，后续业务更改，就需要在任何引用该类的源代码内进行更改，光是查找所有依赖就很消耗时间了，更别说要一个一个修改了。</p></blockquote><p>工厂模式的定义：定义一个创建产品对象的工厂接口，将产品对象的实际创建工作推迟到具体子工厂类当中。这满足创建型模式中所要求的“创建与使用相分离”的特点。</p><p>按实际业务场景划分，工厂模式有 3 种不同的实现方式，分别是<strong>简单工厂模式</strong>、<strong>工厂方法模式</strong>和<strong>抽象工厂模式</strong>。</p><h2 id="二、简单工厂模式概述"><a href="#二、简单工厂模式概述" class="headerlink" title="二、简单工厂模式概述"></a>二、简单工厂模式概述</h2><p>我们把被创建的对象称为“产品”，把创建产品的对象称为“工厂”。如果要创建的产品不多，<strong>只要一个工厂类</strong>就可以完成，这种模式叫“<strong>简单工厂模式</strong>”。</p><p>在简单工厂模式中创建实例的方法通常为静态（static）方法，因此简单工厂模式（Simple Factory Pattern）又叫作静态工厂方法模式（Static Factory Method Pattern）。</p><p>简单来说，简单工厂模式有一个具体的工厂类，可以生成多个不同的产品，属于创建型设计模式。简单工厂模式不在 GoF 23 种设计模式之列。</p><p>简单工厂模式每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度，违背了“开闭原则”。</p><blockquote><p>“工厂方法模式”是对简单工厂模式的进一步抽象化，其好处是可以使系统在不修改原来代码的情况下引进新的产品，即满足开闭原则。</p></blockquote><h2 id="三、简单工厂模式的优点和缺点"><a href="#三、简单工厂模式的优点和缺点" class="headerlink" title="三、简单工厂模式的优点和缺点"></a>三、简单工厂模式的优点和缺点</h2><p>优点：</p><ul><li>工厂类包含必要的逻辑判断，可以决定在什么时候创建哪一个产品的实例。客户端可以免除直接创建产品对象的职责，很方便的创建出相应的产品。工厂和产品的职责区分明确。</li><li>客户端无需知道所创建具体产品的类名，只需知道参数即可。</li><li>也可以引入配置文件，在不修改客户端代码的情况下更换和添加新的具体产品类。</li></ul><p>缺点：</p><ul><li>简单工厂模式的工厂类单一，负责所有产品的创建，职责过重，一旦异常，整个系统将受影响。且工厂类代码会非常臃肿，违背高聚合原则。</li><li>使用简单工厂模式会增加系统中类的个数（引入新的工厂类），增加系统的复杂度和理解难度。</li><li>系统扩展困难，一旦增加新产品不得不修改工厂逻辑，在产品类型较多时，可能造成逻辑过于复杂。</li><li>简单工厂模式使用了 static 工厂方法，造成工厂角色无法形成基于继承的等级结构。</li></ul><h2 id="四、简单工厂模式的应用场景"><a href="#四、简单工厂模式的应用场景" class="headerlink" title="四、简单工厂模式的应用场景"></a>四、简单工厂模式的应用场景</h2><p>对于产品种类相对较少的情况，考虑使用简单工厂模式。使用简单工厂模式的客户端只需要传入工厂类的参数，不需要关心如何创建对象的逻辑，可以很方便地创建所需产品。</p><h2 id="五、简单工厂模式的结构与实现"><a href="#五、简单工厂模式的结构与实现" class="headerlink" title="五、简单工厂模式的结构与实现"></a>五、简单工厂模式的结构与实现</h2><h3 id="1-简单工厂模式的结构"><a href="#1-简单工厂模式的结构" class="headerlink" title="1. 简单工厂模式的结构"></a>1. 简单工厂模式的结构</h3><p>简单工厂模式的主要角色如下：</p><ul><li>简单工厂（SimpleFactory）：是简单工厂模式的核心，负责实现创建所有实例的内部逻辑。工厂类的创建产品类的方法可以被外界直接调用，创建所需的产品对象。</li><li>抽象产品（Product）：是简单工厂创建的所有对象的父类，负责描述所有实例共有的公共接口。</li><li>具体产品（ConcreteProduct）：是简单工厂模式的创建目标。</li></ul><h3 id="2-简单工厂模式的实现"><a href="#2-简单工厂模式的实现" class="headerlink" title="2. 简单工厂模式的实现"></a>2. 简单工厂模式的实现</h3><pre><code>public class Client {    public static void main(String[] args) {    }    //抽象产品    public interface Product {        void show();    }    //具体产品：ProductA    static class ConcreteProduct1 implements Product {        public void show() {            System.out.println(&quot;具体产品1显示...&quot;);        }    }    //具体产品：ProductB    static class ConcreteProduct2 implements Product {        public void show() {            System.out.println(&quot;具体产品2显示...&quot;);        }    }    final class Const {        static final int PRODUCT_A = 0;        static final int PRODUCT_B = 1;        static final int PRODUCT_C = 2;    }    static class SimpleFactory {        public static Product makeProduct(int kind) {            switch (kind) {                case Const.PRODUCT_A:                    return new ConcreteProduct1();                case Const.PRODUCT_B:                    return new ConcreteProduct2();            }            return null;        }    }}</code></pre><h2 id="六、简单工厂模式的实际应用"><a href="#六、简单工厂模式的实际应用" class="headerlink" title="六、简单工厂模式的实际应用"></a>六、简单工厂模式的实际应用</h2><h4 id="1-简单工厂模式在JDK源码中的应用"><a href="#1-简单工厂模式在JDK源码中的应用" class="headerlink" title="1. 简单工厂模式在JDK源码中的应用"></a>1. 简单工厂模式在JDK源码中的应用</h4><p>简单工厂模式在 JDK 源码中无处不在，下面以 Calendar 类为例讲解简单工厂模式在 JDK 源码中的应用。Calendar 类的 getInstance() 方法源码如下：</p><pre><code>public static Calendar getInstance(TimeZone zone, Locale aLocale){    return createCalendar(zone, aLocale);}</code></pre><p>进入 createCalendar() 方法中，源码如下：</p><pre><code>private static Calendar createCalendar(TimeZone zone, Locale aLocale) {    CalendarProvider provider =        LocaleProviderAdapter.getAdapter(CalendarProvider.class, aLocale)                             .getCalendarProvider();    if (provider != null) {        try {            return provider.getInstance(zone, aLocale);        } catch (IllegalArgumentException iae) {            // fall back to the default instantiation        }    }    Calendar cal = null;    if (aLocale.hasExtensions()) {        String caltype = aLocale.getUnicodeLocaleType(&quot;ca&quot;);        if (caltype != null) {            switch (caltype) {            case &quot;buddhist&quot;:            cal = new BuddhistCalendar(zone, aLocale);                break;            case &quot;japanese&quot;:                cal = new JapaneseImperialCalendar(zone, aLocale);                break;            case &quot;gregory&quot;:                cal = new GregorianCalendar(zone, aLocale);                break;            }        }    }    if (cal == null) {        // If no known calendar type is explicitly specified,        // perform the traditional way to create a Calendar:        // create a BuddhistCalendar for th_TH locale,        // a JapaneseImperialCalendar for ja_JP_JP locale, or        // a GregorianCalendar for any other locales.        // NOTE: The language, country and variant strings are interned.        if (aLocale.getLanguage() == &quot;th&quot; &amp;&amp; aLocale.getCountry() == &quot;TH&quot;) {            cal = new BuddhistCalendar(zone, aLocale);        } else if (aLocale.getVariant() == &quot;JP&quot; &amp;&amp; aLocale.getLanguage() == &quot;ja&quot;                   &amp;&amp; aLocale.getCountry() == &quot;JP&quot;) {            cal = new JapaneseImperialCalendar(zone, aLocale);        } else {            cal = new GregorianCalendar(zone, aLocale);        }    }    return cal;}</code></pre><h4 id="2-简单工厂模式在Logback源码中的应用"><a href="#2-简单工厂模式在Logback源码中的应用" class="headerlink" title="2. 简单工厂模式在Logback源码中的应用"></a>2. 简单工厂模式在Logback源码中的应用</h4><p>在大家经常使用的 Logback 中，也可以看到 LoggerFactory 中有多个重载的方法 getLogger()。</p><pre><code>public static Logger getLogger(String name){    ILoggerFactory iLoggerFactory = getILoggerFactory();    return iLoggerFactory.getLogger(name);}public static Logger getLogger(Class clazz){    return getLogger(clazz.getName());}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原型模式</title>
      <link href="/2021/12/27/she-ji-mo-shi/yuan-xing-mo-shi/"/>
      <url>/2021/12/27/she-ji-mo-shi/yuan-xing-mo-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="一、原型模式的定义"><a href="#一、原型模式的定义" class="headerlink" title="一、原型模式的定义"></a>一、原型模式的定义</h2><p>原型（Prototype）模式的定义：用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型相同或相似的新对象。</p><h2 id="二、原型模式的优点和缺点"><a href="#二、原型模式的优点和缺点" class="headerlink" title="二、原型模式的优点和缺点"></a>二、原型模式的优点和缺点</h2><p>优点：</p><ul><li>Java 自带的原型模式基于内存二进制流的复制，在性能上比直接 new 一个对象更加优良。</li><li>可以使用深克隆方式保存对象的状态，使用原型模式将对象复制一份，并将其状态保存起来，简化了创建对象的过程，以便在需要的时候使用（例如恢复到历史某一状态），可辅助实现撤销操作。</li></ul><p>缺点：</p><ul><li>需要为每一个类都配置一个 clone 方法</li><li>clone 方法位于类的内部，当对已有类进行改造的时候，需要修改代码，违背了开闭原则。</li><li>当实现深克隆时，需要编写较为复杂的代码，而且当对象之间存在多重嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来会比较麻烦。</li></ul><h2 id="三、原型模式的应用场景"><a href="#三、原型模式的应用场景" class="headerlink" title="三、原型模式的应用场景"></a>三、原型模式的应用场景</h2><p>原型模式通常适用于以下场景。</p><ul><li>对象之间相同或相似，即只是个别的几个属性不同的时候。</li><li>创建对象成本较大，例如初始化时间长，占用CPU太多，或者占用网络资源太多等，需要优化资源。</li><li>创建一个对象需要繁琐的数据准备或访问权限等，需要提高性能或者提高安全性。</li><li>系统中大量使用该类对象，且各个调用者都需要给它的属性重新赋值。</li></ul><h2 id="四、原型模式的结构与实现"><a href="#四、原型模式的结构与实现" class="headerlink" title="四、原型模式的结构与实现"></a>四、原型模式的结构与实现</h2><h3 id="1-原型模式的结构"><a href="#1-原型模式的结构" class="headerlink" title="1. 原型模式的结构"></a>1. 原型模式的结构</h3><p>原型模式的主要角色如下：</p><ul><li>抽象原型类：规定了具体原型对象必须实现的接口。</li><li>具体原型类：实现抽象原型类的 clone() 方法，它是可被复制的对象。</li><li>访问类：使用具体原型类中的 clone() 方法来复制新的对象。</li></ul><h3 id="2-原型模式的实现"><a href="#2-原型模式的实现" class="headerlink" title="2. 原型模式的实现"></a>2. 原型模式的实现</h3><p>原型模式的克隆分为浅克隆和深克隆。</p><ul><li>浅克隆：创建一个新对象，新对象的属性和原来对象完全相同，对于非基本类型属性，仍指向原有属性所指向的对象的内存地址。</li><li>深克隆：创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址。</li></ul><p>Java 中的 Object 类提供了浅克隆的 clone() 方法，具体原型类只要实现 Cloneable 接口就可实现对象的浅克隆，这里的 Cloneable 接口就是抽象原型类。其代码如下：</p><pre><code>// 具体原型类class Realizetype implements Cloneable {    Realizetype() {        System.out.println(&quot;具体原型创建成功！&quot;);    }    public Object clone() throws CloneNotSupportedException {        System.out.println(&quot;具体原型复制成功！&quot;);        return (Realizetype) super.clone();    }}// 原型模式的测试类public class PrototypeTest {    public static void main(String[] args) throws CloneNotSupportedException {        Realizetype obj1 = new Realizetype();        Realizetype obj2 = (Realizetype) obj1.clone();        System.out.println(&quot;obj1==obj2?&quot; + (obj1 == obj2));    }}</code></pre><h2 id="五、原型模式的实际应用"><a href="#五、原型模式的实际应用" class="headerlink" title="五、原型模式的实际应用"></a>五、原型模式的实际应用</h2><h4 id="1-原型模式在JDK源码中的应用"><a href="#1-原型模式在JDK源码中的应用" class="headerlink" title="1. 原型模式在JDK源码中的应用"></a>1. 原型模式在JDK源码中的应用</h4><p>ArrayList的clone方法，代码如下：</p><pre><code>public Object clone() {    try {        ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) super.clone();        v.elementData = Arrays.copyOf(elementData, size);        v.modCount = 0;        return v;    } catch (CloneNotSupportedException e) {        throw new InternalError(e);    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例模式</title>
      <link href="/2021/12/20/she-ji-mo-shi/dan-li-mo-shi/"/>
      <url>/2021/12/20/she-ji-mo-shi/dan-li-mo-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="一、单例模式的定义与特点"><a href="#一、单例模式的定义与特点" class="headerlink" title="一、单例模式的定义与特点"></a>一、单例模式的定义与特点</h2><p>单例（Singleton）模式的定义：指一个类只有一个实例，且该类能自行创建这个实例的一种模式。</p><p>单例模式有3个特点：</p><ol><li>单例类只有一个实例对象；</li><li>该单例对象必须由单例类自行创建；</li><li>单例类对外提供一个访问该单例的全局访问点。</li></ol><h2 id="二、单例模式的优点和缺点"><a href="#二、单例模式的优点和缺点" class="headerlink" title="二、单例模式的优点和缺点"></a>二、单例模式的优点和缺点</h2><p>优点：</p><ul><li>单例模式可以保证内存里只有一个实例，减少了内存的开销。</li><li>可以避免对资源的多重占用。</li><li>单例模式设置全局访问点，可以优化和共享资源的访问。</li></ul><p>缺点：</p><ul><li>单例模式一般没有接口，扩展困难。如果要扩展，则除了修改原来的代码，没有第二种途径，违背开闭原则。</li><li>在并发测试中，单例模式不利于代码调试。在调试过程中，如果单例中的代码没有执行完，也不能模拟生成一个新的对象。</li><li>单例模式的功能代码通常写在一个类中，如果功能设计不合理，则很容易违背单一职责原则。</li></ul><h2 id="三、单例模式的应用场景"><a href="#三、单例模式的应用场景" class="headerlink" title="三、单例模式的应用场景"></a>三、单例模式的应用场景</h2><p>对于 Java 来说，单例模式可以<strong>保证在一个JVM中只存在单一实例</strong>。单例模式的应用场景主要有以下几个方面。</p><ul><li>需要频繁创建的一些类，使用单例可以降低系统的内存压力，减少 GC。</li><li>某些类创建实例时占用资源较多，或实例化耗时较长，且经常使用。</li><li>某类需要频繁实例化，而创建的对象又频繁被销毁的时候，如多线程的线程池、网络连接池等。</li><li>某类只要求生成一个对象的时候，如一个班中的班长、每个人的身份证号等。</li><li>频繁访问数据库或文件的对象。</li><li>对于一些控制硬件级别的操作，或者从系统上来讲应当是单一控制逻辑的操作，如果有多个实例，则系统会完全乱套。</li><li>当对象需要被共享的场合。由于单例模式只允许创建一个对象，共享该对象可以节省内存，并加快对象访问速度。如 Web 中的配置对象、数据库的连接池等。</li></ul><h2 id="四、单例模式的结构与实现"><a href="#四、单例模式的结构与实现" class="headerlink" title="四、单例模式的结构与实现"></a>四、单例模式的结构与实现</h2><h3 id="1-单例模式的结构"><a href="#1-单例模式的结构" class="headerlink" title="1. 单例模式的结构"></a>1. 单例模式的结构</h3><p>单例模式的主要角色如下：</p><ul><li>单例类：包含一个实例且能自行创建这个实例的类。</li><li>访问类：使用单例的类。</li></ul><h3 id="2-单例模式的实现"><a href="#2-单例模式的实现" class="headerlink" title="2. 单例模式的实现"></a>2. 单例模式的实现</h3><h4 id="1-饿汉式"><a href="#1-饿汉式" class="headerlink" title="1. 饿汉式"></a>1. 饿汉式</h4><p>该模式的特点是类一旦加载就创建一个单例，保证在调用 getInstance 方法之前单例已经存在了。</p><pre><code>public class HungrySingleton {    private static final HungrySingleton instance = new HungrySingleton();    private HungrySingleton() {    }    public static HungrySingleton getInstance() {        return instance;    }}</code></pre><h4 id="2-懒汉式"><a href="#2-懒汉式" class="headerlink" title="2. 懒汉式"></a>2. 懒汉式</h4><p>该模式的特点是类加载时没有生成单例，只有当第一次调用 getlnstance 方法时才去创建这个单例。</p><pre><code>public class LazySingleton {    private static volatile LazySingleton instance = null;    private LazySingleton() {    }    public static LazySingleton getInstance() {        if (instance == null) {            synchronized(LazySingleton.class) {                if (instance == null) {                    instance = new LazySingleton();                }            }        }        return instance;    }}</code></pre><h4 id="3-IoDH"><a href="#3-IoDH" class="headerlink" title="3. IoDH"></a>3. IoDH</h4><p>在IoDH中，我们在单例类中增加一个静态(static)内部类，在该内部类中创建单例对象，再将该单例对象通过getInstance()方法返回给外部使用。通过使用IoDH，我们既可以实现延迟加载，又可以保证线程安全，不影响系统性能，不失为一种最好的Java语言单例模式实现方式。</p><pre><code>class Singleton {    private Singleton() {    }    private static class HolderClass {        private final static Singleton instance = new Singleton();    }    public static Singleton getInstance() {        return HolderClass.instance;    }}</code></pre><h2 id="五、单例模式的实际应用"><a href="#五、单例模式的实际应用" class="headerlink" title="五、单例模式的实际应用"></a>五、单例模式的实际应用</h2><h4 id="1-单例模式在JDK中的应用"><a href="#1-单例模式在JDK中的应用" class="headerlink" title="1. 单例模式在JDK中的应用"></a>1. 单例模式在JDK中的应用</h4><p>JDK 中 Runtime 类使用了单例模式，源码如下：</p><pre><code>public class Runtime {    private static Runtime currentRuntime = new Runtime();    public static Runtime getRuntime() {        return currentRuntime;    }    private Runtime() {    }}</code></pre><h4 id="2-单例模式在Spring中的应用"><a href="#2-单例模式在Spring中的应用" class="headerlink" title="2. 单例模式在Spring中的应用"></a>2. 单例模式在Spring中的应用</h4><p>Spring bean 默认是单例模式。</p><h4 id="3-单例模式在MyBatis中的应用"><a href="#3-单例模式在MyBatis中的应用" class="headerlink" title="3. 单例模式在MyBatis中的应用"></a>3. 单例模式在MyBatis中的应用</h4><p>在MyBatis中有两个地方用到单例模式，ErrorContext和LogFactory，其中ErrorContext是用在<strong>每个线程范围内</strong>的单例，用于记录该线程的执行环境错误信息，而LogFactory则是提供给<strong>整个MyBatis</strong>使用的日志工厂，用于获得针对项目配置好的日志对象。</p><p>ErrorContext源码如下：</p><pre><code>public class ErrorContext {    private static final ThreadLocal&lt;ErrorContext&gt; LOCAL = new ThreadLocal&lt;ErrorContext&gt;();    private ErrorContext() {    }    public static ErrorContext instance() {        ErrorContext context = LOCAL.get();        if (context == null) {            context = new ErrorContext();            LOCAL.set(context);        }        return context;    }}</code></pre><p>LogFactory源码如下：</p><pre><code>public final class LogFactory {    private static Constructor&lt;? extends Log&gt; logConstructor;    private LogFactory() {    }    public static Log getLog(Class&lt;?&gt; aClass) {        return getLog(aClass.getName());    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>美妙生活之自习室被夸奖</title>
      <link href="/2021/12/18/sheng-huo/mei-miao-sheng-huo-zhi-zi-xi-shi-bei-kua-jiang/"/>
      <url>/2021/12/18/sheng-huo/mei-miao-sheng-huo-zhi-zi-xi-shi-bei-kua-jiang/</url>
      
        <content type="html"><![CDATA[<p>在自习室写代码，旁边的小哥哥问”您这个是Python吗？”，我说”不是，是Java开发语言”。</p><p>他若有所思地点点头，竖起了大拇指，然后说编程是一项很需要掌握的技术。他介绍自己是做金融的，公司里面也有很多程序员，他很羡慕，说想学Python去分析数据。我鼓励他Python很容易入门，相信他一定能掌握。</p><p>临走的时候，我说如果有机会再碰到，我们可以一起交流一下。</p><p>生活就是这样，总能在某个时间，某个地点，遇到某个人，发生某些有趣的事！</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>性能优化</title>
      <link href="/2021/12/18/xing-neng-you-hua/xing-neng-you-hua/"/>
      <url>/2021/12/18/xing-neng-you-hua/xing-neng-you-hua/</url>
      
        <content type="html"><![CDATA[<h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>最近公司项目性能问题很多，在解决的过程中总结了一些性能优化的经验。</p><h3 id="定位慢接口-慢SQL"><a href="#定位慢接口-慢SQL" class="headerlink" title="定位慢接口/慢SQL"></a>定位慢接口/慢SQL</h3><ol><li>在代码中通过StopWatch打印代码段或接口执行时间；</li><li>通过公司自研工具Hippo Monitor-&gt;服务监控-&gt;调用链监控-&gt;输入接口名称查询耗时；</li><li>通过阿里巴巴开源的Java诊断工具arthas追踪各接口执行时间。</li></ol><h3 id="导致慢的原因及解决方案"><a href="#导致慢的原因及解决方案" class="headerlink" title="导致慢的原因及解决方案"></a>导致慢的原因及解决方案</h3><h4 id="一、粗粒度"><a href="#一、粗粒度" class="headerlink" title="一、粗粒度"></a>一、粗粒度</h4><h5 id="1-单线程处理大数据"><a href="#1-单线程处理大数据" class="headerlink" title="1. 单线程处理大数据"></a>1. 单线程处理大数据</h5><p>改完多线程处理。</p><h5 id="2-某个操作-方法执行次数太多"><a href="#2-某个操作-方法执行次数太多" class="headerlink" title="2. 某个操作/方法执行次数太多"></a>2. 某个操作/方法执行次数太多</h5><p>比如我们使用easy excel导入时，在一个for循环中使用poi的CellStyle.cloneStyleFrom方法拷贝单元格样式，耗时非常严重。</p><p>在for循环外面定义一个或几个变量保存拷贝过的样式，如果样式已存在，直接返回，不需要每次都拷贝。</p><h4 id="二、细粒度"><a href="#二、细粒度" class="headerlink" title="二、细粒度"></a>二、细粒度</h4><h5 id="1-慢SQL"><a href="#1-慢SQL" class="headerlink" title="1. 慢SQL"></a>1. 慢SQL</h5><ul><li>根据业务，优化SQL实现逻辑</li><li>让SQL尽可能走索引</li><li>修改SQL写法（需要一定经验或多次尝试）</li></ul>]]></content>
      
      
      <categories>
          
          <category> 性能优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>美妙生活之租房被套路</title>
      <link href="/2021/12/18/sheng-huo/mei-miao-sheng-huo-zhi-zu-fang-bei-tao-lu/"/>
      <url>/2021/12/18/sheng-huo/mei-miao-sheng-huo-zhi-zu-fang-bei-tao-lu/</url>
      
        <content type="html"><![CDATA[<h4 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h4><p>我和同事准备合租，前前后后找了很多地方，最后选中了一个小区，然后通过小区中介开始找房子，于是就有了下面被套路的经历。</p><h4 id="租房套路"><a href="#租房套路" class="headerlink" title="租房套路"></a>租房套路</h4><ol><li>中介根据你的身份以及你的预算，给你找1套或2套特别合适的房子，然后给你报个价钱，你可能会出低一点，即便超出底线，他也会答应你，帮你和房东去谈。</li><li>如果看得出你喜欢之前的房子，下次就会带你去看价格很贵或者同等价格但是不好的房子，这样你就会觉得最初的几套好。</li><li>如果你定了具体的某一套房子，会把你叫过去和房东聊，而且之前会交代你一些事情（包括让你先转押金，表现出你真的想租这套房，到时容易和房东谈妥价格等等），让你配合他。到了之后你和房东、中介一起交谈，不一会房东会出去接个电话或者打个电话（这个也是当初中介和房东商量好的），然后中介会说是之前有人也看过房子，而且价格更高，一般高出400-500吧，房东这会出去接电话，多半是因为这个事情。</li><li>接电话回来以后，房东一般会说要几个小时后才做决定，然后中介会直接挑明这个话题，问房东是不是要等上一个看房的人做决定，他们这样一配合，会让你觉得这个房子有点抢手。然后中介会让房东回去，再在你面前假装各种出谋划策，表现出为你争取这套房子的努力。</li><li>最后中介和你说，可不可以提高一下价格，因为房子很有可能租给别人，如果你提高了，那么你就上钩了。对于着急租房的人，这样的套路成功率很高！</li></ol><h4 id="小感悟"><a href="#小感悟" class="headerlink" title="小感悟"></a>小感悟</h4><p>这套做法最高明之处就是分别透漏给房东和租客有限的信息（更多时候是只透漏给租客有限的信息），然后给他们指出对自己有利的做法，双方为了自己，纷纷尽情表演，殊不知这一切都是中介导演的。</p><p>生活中很多时候就是这样，由于我们掌握的信息有限，再加上一些客观因素，比如急于做成某件事情，导致一时难以做出最清晰的决定。</p><p>希望以后的日子里，在做一些重大决定的时候，可以冷静一点，尽量搜集更多的信息，这样才能做出相对理智的决定。对于那些不太重要的决定，也不需要那么斤斤计较，毕竟太理智，生活就没有乐趣了。</p><p>租房子就是一个不重要的事情，被套路就被套路了，重要的是和谁一起被套路！[捂脸]</p><p>我的同事说“享受吧，被别人套，以后就会套人（肯定不会，哈哈），或防套”，“生活就是这样，防不胜防，关键是看代价有多大”。</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式概述</title>
      <link href="/2021/12/11/she-ji-mo-shi/she-ji-mo-shi-gai-shu/"/>
      <url>/2021/12/11/she-ji-mo-shi/she-ji-mo-shi-gai-shu/</url>
      
        <content type="html"><![CDATA[<h2 id="一、什么是设计模式"><a href="#一、什么是设计模式" class="headerlink" title="一、什么是设计模式"></a>一、什么是设计模式</h2><p>设计模式是指在软件设计中，被人反复使用的、经过分类编目的、代码设计经验的总结。<br>使用设计模式的目的是为了可重用代码，提高代码的可扩展性和可维护性。</p><h2 id="二、设计模式七大原则"><a href="#二、设计模式七大原则" class="headerlink" title="二、设计模式七大原则"></a>二、设计模式七大原则</h2><p>面向对象的设计模式有七大基本原则：</p><ul><li>开闭原则</li><li>单一职责原则</li><li>里氏替换原则</li><li>依赖倒置原则</li><li>接口隔离原则</li><li>迪米特原则/最少知识原则</li><li>合成/聚合复用原则</li></ul><h4 id="1-开闭原则"><a href="#1-开闭原则" class="headerlink" title="1. 开闭原则"></a>1. 开闭原则</h4><p>一个软件实体，如类、模块和函数应该<strong>对扩展开放，对修改关闭</strong>。模块应尽量在不修改原码的情况下进行扩展，防止引入新的错误。</p><h5 id="如何实现对扩展开放，对修改关闭"><a href="#如何实现对扩展开放，对修改关闭" class="headerlink" title="如何实现对扩展开放，对修改关闭"></a>如何实现对扩展开放，对修改关闭</h5><p>需要对系统进行抽象化设计，抽象可以基于抽象类或接口。</p><ol><li>通过接口或抽象类约束扩展，对扩展进行边界限定，不允许出现在抽象类或接口中不存在的public方法，也就是扩展必须添加具体实现而不是修改具体方法。</li><li>参数类型、引用对象尽量使用接口或抽象类，而不是实现类，这样就能尽量保证抽象层是稳定的。</li><li>一般抽象模块设计完成，不允许修改接口或者抽象方法的定义。</li></ol><h4 id="2-单一职责原则"><a href="#2-单一职责原则" class="headerlink" title="2. 单一职责原则"></a>2. 单一职责原则</h4><p><strong>一个类只负责一个功能领域中的相应职责。</strong> 职责太多会导致职责耦合在一起，一个职责的变化会影响其他职责。此原则的核心就是解耦和增强内聚性。</p><h4 id="3-里氏替换原则"><a href="#3-里氏替换原则" class="headerlink" title="3. 里氏替换原则"></a>3. 里氏替换原则</h4><p><strong>所有引用基类的地方必须能透明地使用其子类的对象。</strong> 里氏替换原则是对开闭原则的补充，开闭原则的关键步骤是抽象化，而基类与子类的继承关系就是抽象化的具体实现。</p><h4 id="4-依赖倒置原则"><a href="#4-依赖倒置原则" class="headerlink" title="4. 依赖倒置原则"></a>4. 依赖倒置原则</h4><p><strong>程序要依赖于抽象接口，不能依赖于具体实现。</strong></p><p>依赖倒置原则要求我们在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类，即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而不要用具体类来做这些事情。为了确保该原则的应用，一个具体类应当只实现接口或抽象类中声明过的方法，而不要给出多余的方法，否则将导致无法调到在子类中增加的新方法。在引入抽象层后，系统将具有很好的灵活性，在程序中尽量使用抽象层进行编程，而将具体类写在配置文件中，这样一来，如果系统行为发生变化，只需对抽象层进行扩展，并修改配置文件，而无需修改原系统的源代码，在不修改的情况下来扩展系统的功能，满足开闭原则。</p><p>在实现依赖倒置原则时，我们需要针对抽象层编程，而将具体类的对象通过依赖注入的方式注入到其他对象中，依赖注入是指当一个对象要与其他对象发生依赖关系时，通过抽象来注入所依赖的对象。常用的注入方式有构造注入、Set注入和接口注入。Spring IOC是此实现的典范。</p><h4 id="5-接口隔离原则"><a href="#5-接口隔离原则" class="headerlink" title="5. 接口隔离原则"></a>5. 接口隔离原则</h4><p>客户端不应该依赖它不需要的接口，<strong>类之间的依赖关系应该建立在最小的接口上</strong>。简单来说就是建立单一的接口，使接口尽量细化，同时接口中的方法尽量少。</p><h4 id="6-迪米特原则-最少知识原则"><a href="#6-迪米特原则-最少知识原则" class="headerlink" title="6. 迪米特原则/最少知识原则"></a>6. 迪米特原则/最少知识原则</h4><p><strong>一个软件实体应当尽可能少的与其他实体发生相互作用。</strong> 迪米特原则不希望类之间建立直接的联系，如果真的需要建立联系，也希望通过它的友元类（中间类或跳转类）来转达。</p><h4 id="7-合成-聚合复用原则"><a href="#7-合成-聚合复用原则" class="headerlink" title="7. 合成/聚合复用原则"></a>7. 合成/聚合复用原则</h4><p><strong>尽量使用合成/聚合，而不是继承达到复用的目的</strong>。继承是“白箱”复用，合成/聚合是“黑箱”复用。一般情况下，只有明确知道派生类和基类满足<code>IS A</code>的时候才选用继承，当满足<code>HAS A</code>或者不能判断的情况下应该选用合成/聚合。</p><h2 id="三、设计模式类型"><a href="#三、设计模式类型" class="headerlink" title="三、设计模式类型"></a>三、设计模式类型</h2><h4 id="1-创建型模式"><a href="#1-创建型模式" class="headerlink" title="1. 创建型模式"></a>1. 创建型模式</h4><p>创建型模式的主要关注点是”怎样创建对象”，它的主要特点是”将对象的创建和使用分离”。这样可以降低系统的耦合度，使用者不需要关注对象的创建细节，对象的创建由相关的工厂来完成。</p><p>创建型模式分为以下5种：</p><ol><li><strong>单例模式</strong><br>某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例。</li><li><strong>原型模式</strong><br>将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。</li><li><strong>工厂方法模式</strong><br>定义一个用于创建产品的接口，由子类决定生产什么产品。</li><li><strong>抽象工厂模式</strong><br>提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。</li><li><strong>建造者模式</strong><br>将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建他们，最后构建成该复杂对象。</li></ol><p>以上5种创建型模式，除了工厂方法模式属于类创建型模式，其他的全部属于对象创建型模式。</p><h4 id="2-结构型模式"><a href="#2-结构型模式" class="headerlink" title="2. 结构型模式"></a>2. 结构型模式</h4><p>结构型模式描述如何将类或对象按某种布局组成更大的结构。它分为类结构型模式和对象结构型模式，前者采用<strong>继承机制</strong>来组织接口和类，后者采用<strong>组合或聚合</strong>来组合对象。</p><p>由于组合关系或聚合关系比继承关系耦合度更低，所以对象结构型模式比类结构型模式具有更大的灵活性。</p><p>结构型模式分为以下7种：</p><ol><li><strong>代理模式</strong><br>为某个对象提供一种代理以控制对该对象的访问。即客户端通过代理间接访问该对象，从而限制、增强或修改该对象的一些特性。</li><li><strong>适配器模式</strong><br>将一个类的接口转换成客户希望的另一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。</li><li><strong>桥接模式</strong><br>将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现的，从而降低了抽象和实现这两个可变维度的耦合度。</li><li><strong>装饰模式</strong><br>动态地给对象增加一些职责，即增加额外的功能。</li><li><strong>外观模式</strong><br>为多个复杂的子系统提供一个一致的接口，使得这些子系统更容易被访问。</li><li><strong>享元模式</strong><br>运用共享技术来有效地支持大量细粒度对象的复用。</li><li><strong>组合模式</strong><br>将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。</li></ol><p>以上7种结构型模式，除了适配器模式分为类结构型模式和对象结构型模式两种，其他全部属于对象结构型模式。</p><h4 id="3-行为型模式"><a href="#3-行为型模式" class="headerlink" title="3. 行为型模式"></a>3. 行为型模式</h4><p>行为型模式用于描述程序在运行时复杂的流程控制，即描述多个类或对象之间怎样互相协作共同完成单个对象无法完成的任务，它涉及算法与对象间职责的分配。</p><p>行为型模式分为类行为模式和对象行为模式，前者采用继承机制在类间分派行为，后者采用组合或聚合在对象间分派行为。由于组合关系或聚合关系比继承关系耦合度低，所以对象行为模式比类行为模式有更大的灵活性。</p><p>行为型模式分为以下11种：</p><ol><li><strong>模板方法模式</strong><br>定义一个操作中的算法骨架，将算法的一些步骤延迟到子类中，使得子类在不改变该算法结构的情况下，重新定义该算法的某些特定步骤。</li><li><strong>策略模式</strong><br>定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。</li><li><strong>命令模式</strong><br>将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分开。</li><li><strong>职责链模式</strong><br>把请求从链中的一个对象传递到另一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。</li><li><strong>状态模式</strong><br>允许一个对象在其内部状态发生改变时改变其行为能力。</li><li><strong>观察者模式</strong><br>多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。</li><li><strong>中介者模式</strong><br>定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。</li><li><strong>迭代器模式</strong><br>提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。</li><li><strong>访问者模式</strong><br>在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。</li><li><strong>备忘录模式</strong><br>在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。</li><li><strong>解释器模式</strong><br>提供如何定义语言的文法，以及对语言句子的解释方法。</li></ol><p>以上11种行为型模式，除了模板方法模式和解释器模式是类行为模式，其他都是对象行为型模式。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建博客过程中遇到的问题</title>
      <link href="/2021/12/07/bo-ke/da-jian-bo-ke-guo-cheng-zhong-yu-dao-de-wen-ti/"/>
      <url>/2021/12/07/bo-ke/da-jian-bo-ke-guo-cheng-zhong-yu-dao-de-wen-ti/</url>
      
        <content type="html"><![CDATA[<h2 id="一、hexo-d-报错"><a href="#一、hexo-d-报错" class="headerlink" title="一、hexo d 报错"></a>一、hexo d 报错</h2><pre><code>fatal: unable to access &#39;https://github.com/huiminghu/huiminghu.github.io.git/&#39;: LibreSSL SSL_connect: SSL_ERROR_SYSCALL in connection to github.com:443</code></pre><p>将config.xml的repository url<br>由<code>https://github.com/huiminghu/huiminghu.github.io.git</code><br>改为<code>git@github.com:huiminghu/huiminghu.github.io.git</code>。</p><h2 id="二、执行n-latest安装node最新版本时报错"><a href="#二、执行n-latest安装node最新版本时报错" class="headerlink" title="二、执行n latest安装node最新版本时报错"></a>二、执行n latest安装node最新版本时报错</h2><pre><code>Error: sudo required (or change ownership, or define N_PREFIX)</code></pre><p>答案原地址：<a href="https://stackoverflow.com/questions/61677951/why-n-throws-error-error-sudo-required-or-change-ownership-or-define-n-prefi" target="_blank" rel="noopener">stackoverflow</a></p><ol><li>You would need to change where n stores node versions ownership<pre><code>sudo mkdir -p /usr/local/n &amp;&amp; sudo chown -R $(whoami) /usr/local/n/</code></pre></li><li>Add yourself to the group and grant write permission<pre><code>sudo dseditgroup -o edit -a $(whoami) -t user wheel</code></pre></li><li>Allow wheel members writing permission on that folder<pre><code>sudo chmod -R g+w /usr/local/n/</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>终于有自己的博客啦</title>
      <link href="/2021/12/05/bo-ke/zhong-yu-you-zi-ji-de-bo-ke-la/"/>
      <url>/2021/12/05/bo-ke/zhong-yu-you-zi-ji-de-bo-ke-la/</url>
      
        <content type="html"><![CDATA[<p>  几年前开始写博客，试过在知乎、简书等公共博客平台写作，但是上面的排版实在不符合自己的”审美”，于是开始折腾自己搭建，试过halo、mblog这些开源的博客框架，也在其基础上做了改进，但是始终达不到自己的要求。而后转战hexo + github pages，刚开始搭建出来，觉得这页面丑爆了，于是在网上搜索是否有修改样式的教程，很幸运看到了韦阳老师开源的hexo-theme-sungod，看到了自己真正喜欢的博客的样子，于是立马star&amp;fork了这个项目，在此基础上做了简单修改，就有了我现在博客的样子。</p><p>  以后我要在这个博客上写下自己的点点滴滴，这个才是真正意义上属于自己的博客！</p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
