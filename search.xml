<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>设计模式概述</title>
      <link href="/2021/12/11/she-ji-mo-shi-gai-shu/"/>
      <url>/2021/12/11/she-ji-mo-shi-gai-shu/</url>
      
        <content type="html"><![CDATA[<h2 id="一、什么是设计模式"><a href="#一、什么是设计模式" class="headerlink" title="一、什么是设计模式"></a>一、什么是设计模式</h2><p>设计模式是指在软件设计中，被人反复使用的、经过分类编目的、代码设计经验的总结。<br>使用设计模式的目的是为了可重用代码，提高代码的可扩展性和可维护性。</p><h2 id="二、设计模式七大原则"><a href="#二、设计模式七大原则" class="headerlink" title="二、设计模式七大原则"></a>二、设计模式七大原则</h2><p>面向对象的设计模式有七大基本原则：</p><ul><li>开闭原则</li><li>单一职责原则</li><li>里氏替换原则</li><li>依赖倒置原则</li><li>接口隔离原则</li><li>迪米特原则/最少知识原则</li><li>合成/聚合复用原则</li></ul><h4 id="1-开闭原则"><a href="#1-开闭原则" class="headerlink" title="1. 开闭原则"></a>1. 开闭原则</h4><p>一个软件实体，如类、模块和函数应该<strong>对扩展开放，对修改关闭</strong>。模块应尽量在不修改原码的情况下进行扩展，防止引入新的错误。</p><h5 id="如何实现对扩展开放，对修改关闭"><a href="#如何实现对扩展开放，对修改关闭" class="headerlink" title="如何实现对扩展开放，对修改关闭"></a>如何实现对扩展开放，对修改关闭</h5><p>需要对系统进行抽象化设计，抽象可以基于抽象类或接口。</p><ol><li>通过接口或抽象类约束扩展，对扩展进行边界限定，不允许出现在抽象类或接口中不存在的public方法，也就是扩展必须添加具体实现而不是修改具体方法。</li><li>参数类型、引用对象尽量使用接口或抽象类，而不是实现类，这样就能尽量保证抽象层是稳定的。</li><li>一般抽象模块设计完成，不允许修改接口或者抽象方法的定义。</li></ol><h4 id="2-单一职责原则"><a href="#2-单一职责原则" class="headerlink" title="2. 单一职责原则"></a>2. 单一职责原则</h4><p><strong>一个类只负责一个功能领域中的相应职责。</strong> 职责太多会导致职责耦合在一起，一个职责的变化会影响其他职责。此原则的核心就是解耦和增强内聚性。</p><h4 id="3-里氏替换原则"><a href="#3-里氏替换原则" class="headerlink" title="3. 里氏替换原则"></a>3. 里氏替换原则</h4><p><strong>所有引用基类的地方必须能透明地使用其子类的对象。</strong> 里氏替换原则是对开闭原则的补充，开闭原则的关键步骤是抽象化，而基类与子类的继承关系就是抽象化的具体实现。</p><h4 id="4-依赖倒置原则"><a href="#4-依赖倒置原则" class="headerlink" title="4. 依赖倒置原则"></a>4. 依赖倒置原则</h4><p><strong>程序要依赖于抽象接口，不能依赖于具体实现。</strong></p><p>依赖倒置原则要求我们在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类，即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而不要用具体类来做这些事情。为了确保该原则的应用，一个具体类应当只实现接口或抽象类中声明过的方法，而不要给出多余的方法，否则将导致无法调到在子类中增加的新方法。在引入抽象层后，系统将具有很好的灵活性，在程序中尽量使用抽象层进行编程，而将具体类写在配置文件中，这样一来，如果系统行为发生变化，只需对抽象层进行扩展，并修改配置文件，而无需修改原系统的源代码，在不修改的情况下来扩展系统的功能，满足开闭原则。</p><p>在实现依赖倒置原则时，我们需要针对抽象层编程，而将具体类的对象通过依赖注入的方式注入到其他对象中，依赖注入是指当一个对象要与其他对象发生依赖关系时，通过抽象来注入所依赖的对象。常用的注入方式有构造注入、Set注入和接口注入。Spring IOC是此实现的典范。</p><h4 id="5-接口隔离原则"><a href="#5-接口隔离原则" class="headerlink" title="5. 接口隔离原则"></a>5. 接口隔离原则</h4><p>客户端不应该依赖它不需要的接口，<strong>类之间的依赖关系应该建立在最小的接口上</strong>。简单来说就是建立单一的接口，使接口尽量细化，同时接口中的方法尽量少。</p><h4 id="6-迪米特原则-最少知识原则"><a href="#6-迪米特原则-最少知识原则" class="headerlink" title="6. 迪米特原则/最少知识原则"></a>6. 迪米特原则/最少知识原则</h4><p><strong>一个软件实体应当尽可能少的与其他实体发生相互作用。</strong> 迪米特原则不希望类之间建立直接的联系，如果真的需要建立联系，也希望通过它的友元类（中间类或跳转类）来转达。</p><h4 id="7-合成-聚合复用原则"><a href="#7-合成-聚合复用原则" class="headerlink" title="7. 合成/聚合复用原则"></a>7. 合成/聚合复用原则</h4><p><strong>尽量使用合成/聚合，而不是继承达到复用的目的</strong>。继承是“白箱”复用，合成/聚合是“黑箱”复用。一般情况下，只有明确知道派生类和基类满足<code>IS A</code>的时候才选用继承，当满足<code>HAS A</code>或者不能判断的情况下应该选用合成/聚合。</p><h2 id="三、设计模式类型"><a href="#三、设计模式类型" class="headerlink" title="三、设计模式类型"></a>三、设计模式类型</h2><h4 id="1-创建型模式"><a href="#1-创建型模式" class="headerlink" title="1. 创建型模式"></a>1. 创建型模式</h4><h4 id="2-结构型模式"><a href="#2-结构型模式" class="headerlink" title="2. 结构型模式"></a>2. 结构型模式</h4><h4 id="3-行为型模式"><a href="#3-行为型模式" class="headerlink" title="3. 行为型模式"></a>3. 行为型模式</h4>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建博客过程中遇到的问题</title>
      <link href="/2021/12/07/da-jian-bo-ke-guo-cheng-zhong-yu-dao-de-wen-ti/"/>
      <url>/2021/12/07/da-jian-bo-ke-guo-cheng-zhong-yu-dao-de-wen-ti/</url>
      
        <content type="html"><![CDATA[<h2 id="一、hexo-d-报错"><a href="#一、hexo-d-报错" class="headerlink" title="一、hexo d 报错"></a>一、hexo d 报错</h2><pre><code>fatal: unable to access &#39;https://github.com/huiminghu/huiminghu.github.io.git/&#39;: LibreSSL SSL_connect: SSL_ERROR_SYSCALL in connection to github.com:443</code></pre><p>将config.xml的repository url<br>由<code>https://github.com/huiminghu/huiminghu.github.io.git</code><br>改为<code>git@github.com:huiminghu/huiminghu.github.io.git</code>。</p><h2 id="二、执行n-latest安装node最新版本时报错"><a href="#二、执行n-latest安装node最新版本时报错" class="headerlink" title="二、执行n latest安装node最新版本时报错"></a>二、执行n latest安装node最新版本时报错</h2><pre><code>Error: sudo required (or change ownership, or define N_PREFIX)</code></pre><p>答案原地址：<a href="https://stackoverflow.com/questions/61677951/why-n-throws-error-error-sudo-required-or-change-ownership-or-define-n-prefi" target="_blank" rel="noopener">stackoverflow</a></p><ol><li>You would need to change where n stores node versions ownership<pre><code>sudo mkdir -p /usr/local/n &amp;&amp; sudo chown -R $(whoami) /usr/local/n/</code></pre></li><li>Add yourself to the group and grant write permission<pre><code>sudo dseditgroup -o edit -a $(whoami) -t user wheel</code></pre></li><li>Allow wheel members writing permission on that folder<pre><code>sudo chmod -R g+w /usr/local/n/</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>终于有自己的博客啦</title>
      <link href="/2021/12/05/zhong-yu-you-zi-ji-de-bo-ke-la/"/>
      <url>/2021/12/05/zhong-yu-you-zi-ji-de-bo-ke-la/</url>
      
        <content type="html"><![CDATA[<p>  几年前开始写博客，试过在知乎、简书等公共博客平台写作，但是上面的排版实在不符合自己的”审美”，于是开始折腾自己搭建，试过halo、mblog这些开源的博客框架，也在其基础上做了改进，但是始终达不到自己的要求。而后转战hexo + github pages，刚开始搭建出来，觉得这页面丑爆了，于是在网上搜索是否有修改样式的教程，很幸运看到了韦阳老师开源的hexo-theme-sungod，看到了自己真正喜欢的博客的样子，于是立马star&amp;fork了这个项目，在此基础上做了简单修改，就有了我现在博客的样子。</p><p>  以后我要在这个博客上写下自己的点点滴滴，这个才是真正意义上属于自己的博客！</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
