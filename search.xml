<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>原型模式</title>
      <link href="/2021/12/27/she-ji-mo-shi/yuan-xing-mo-shi/"/>
      <url>/2021/12/27/she-ji-mo-shi/yuan-xing-mo-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="一、原型模式的定义与特点"><a href="#一、原型模式的定义与特点" class="headerlink" title="一、原型模式的定义与特点"></a>一、原型模式的定义与特点</h2><p>原型（Prototype）模式的定义：用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型相同或相似的新对象。</p><h2 id="二、原型模式的优点和缺点"><a href="#二、原型模式的优点和缺点" class="headerlink" title="二、原型模式的优点和缺点"></a>二、原型模式的优点和缺点</h2><p>原型模式的优点：</p><ul><li>Java 自带的原型模式基于内存二进制流的复制，在性能上比直接 new 一个对象更加优良。</li><li>可以使用深克隆方式保存对象的状态，使用原型模式将对象复制一份，并将其状态保存起来，简化了创建对象的过程，以便在需要的时候使用（例如恢复到历史某一状态），可辅助实现撤销操作。</li></ul><p>原型模式的缺点：</p><ul><li>需要为每一个类都配置一个 clone 方法</li><li>clone 方法位于类的内部，当对已有类进行改造的时候，需要修改代码，违背了开闭原则。</li><li>当实现深克隆时，需要编写较为复杂的代码，而且当对象之间存在多重嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来会比较麻烦。</li></ul><h2 id="三、原型模式的应用场景"><a href="#三、原型模式的应用场景" class="headerlink" title="三、原型模式的应用场景"></a>三、原型模式的应用场景</h2><p>原型模式通常适用于以下场景。</p><ul><li>对象之间相同或相似，即只是个别的几个属性不同的时候。</li><li>创建对象成本较大，例如初始化时间长，占用CPU太多，或者占用网络资源太多等，需要优化资源。</li><li>创建一个对象需要繁琐的数据准备或访问权限等，需要提高性能或者提高安全性。</li><li>系统中大量使用该类对象，且各个调用者都需要给它的属性重新赋值。</li></ul><h2 id="四、原型模式的结构与实现"><a href="#四、原型模式的结构与实现" class="headerlink" title="四、原型模式的结构与实现"></a>四、原型模式的结构与实现</h2><h3 id="1-原型模式的结构"><a href="#1-原型模式的结构" class="headerlink" title="1. 原型模式的结构"></a>1. 原型模式的结构</h3><p>原型模式的主要角色如下：</p><ul><li>抽象原型类：规定了具体原型对象必须实现的接口。</li><li>具体原型类：实现抽象原型类的 clone() 方法，它是可被复制的对象。</li><li>访问类：使用具体原型类中的 clone() 方法来复制新的对象。</li></ul><h3 id="2-原型模式的实现"><a href="#2-原型模式的实现" class="headerlink" title="2. 原型模式的实现"></a>2. 原型模式的实现</h3><p>原型模式的克隆分为浅克隆和深克隆。</p><ul><li>浅克隆：创建一个新对象，新对象的属性和原来对象完全相同，对于非基本类型属性，仍指向原有属性所指向的对象的内存地址。</li><li>深克隆：创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址。</li></ul><p>Java 中的 Object 类提供了浅克隆的 clone() 方法，具体原型类只要实现 Cloneable 接口就可实现对象的浅克隆，这里的 Cloneable 接口就是抽象原型类。其代码如下：</p><pre><code>// 具体原型类class Realizetype implements Cloneable {    Realizetype() {        System.out.println(&quot;具体原型创建成功！&quot;);    }    public Object clone() throws CloneNotSupportedException {        System.out.println(&quot;具体原型复制成功！&quot;);        return (Realizetype) super.clone();    }}// 原型模式的测试类public class PrototypeTest {    public static void main(String[] args) throws CloneNotSupportedException {        Realizetype obj1 = new Realizetype();        Realizetype obj2 = (Realizetype) obj1.clone();        System.out.println(&quot;obj1==obj2?&quot; + (obj1 == obj2));    }}</code></pre><h2 id="五、原型模式实际应用"><a href="#五、原型模式实际应用" class="headerlink" title="五、原型模式实际应用"></a>五、原型模式实际应用</h2><h4 id="1-原型模式在JDK源码中的应用"><a href="#1-原型模式在JDK源码中的应用" class="headerlink" title="1. 原型模式在JDK源码中的应用"></a>1. 原型模式在JDK源码中的应用</h4><p>ArrayList的clone方法，代码如下：</p><pre><code>public Object clone() {    try {        ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) super.clone();        v.elementData = Arrays.copyOf(elementData, size);        v.modCount = 0;        return v;    } catch (CloneNotSupportedException e) {        throw new InternalError(e);    }}</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>单例模式</title>
      <link href="/2021/12/20/she-ji-mo-shi/dan-li-mo-shi/"/>
      <url>/2021/12/20/she-ji-mo-shi/dan-li-mo-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="一、单例模式的定义与特点"><a href="#一、单例模式的定义与特点" class="headerlink" title="一、单例模式的定义与特点"></a>一、单例模式的定义与特点</h2><p>单例（Singleton）模式的定义：指一个类只有一个实例，且该类能自行创建这个实例的一种模式。</p><p>单例模式有3个特点：</p><ol><li>单例类只有一个实例对象；</li><li>该单例对象必须由单例类自行创建；</li><li>单例类对外提供一个访问该单例的全局访问点。</li></ol><h2 id="二、单例模式的优点和缺点"><a href="#二、单例模式的优点和缺点" class="headerlink" title="二、单例模式的优点和缺点"></a>二、单例模式的优点和缺点</h2><p>单例模式的优点：</p><ul><li>单例模式可以保证内存里只有一个实例，减少了内存的开销。</li><li>可以避免对资源的多重占用。</li><li>单例模式设置全局访问点，可以优化和共享资源的访问。</li></ul><p>单例模式的缺点：</p><ul><li>单例模式一般没有接口，扩展困难。如果要扩展，则除了修改原来的代码，没有第二种途径，违背开闭原则。</li><li>在并发测试中，单例模式不利于代码调试。在调试过程中，如果单例中的代码没有执行完，也不能模拟生成一个新的对象。</li><li>单例模式的功能代码通常写在一个类中，如果功能设计不合理，则很容易违背单一职责原则。</li></ul><h2 id="三、单例模式的应用场景"><a href="#三、单例模式的应用场景" class="headerlink" title="三、单例模式的应用场景"></a>三、单例模式的应用场景</h2><p>对于 Java 来说，单例模式可以<strong>保证在一个JVM中只存在单一实例</strong>。单例模式的应用场景主要有以下几个方面。</p><ul><li>需要频繁创建的一些类，使用单例可以降低系统的内存压力，减少 GC。</li><li>某些类创建实例时占用资源较多，或实例化耗时较长，且经常使用。</li><li>某类需要频繁实例化，而创建的对象又频繁被销毁的时候，如多线程的线程池、网络连接池等。</li><li>某类只要求生成一个对象的时候，如一个班中的班长、每个人的身份证号等。</li><li>频繁访问数据库或文件的对象。</li><li>对于一些控制硬件级别的操作，或者从系统上来讲应当是单一控制逻辑的操作，如果有多个实例，则系统会完全乱套。</li><li>当对象需要被共享的场合。由于单例模式只允许创建一个对象，共享该对象可以节省内存，并加快对象访问速度。如 Web 中的配置对象、数据库的连接池等。</li></ul><h2 id="四、单例模式的结构与实现"><a href="#四、单例模式的结构与实现" class="headerlink" title="四、单例模式的结构与实现"></a>四、单例模式的结构与实现</h2><h3 id="1-单例模式的结构"><a href="#1-单例模式的结构" class="headerlink" title="1. 单例模式的结构"></a>1. 单例模式的结构</h3><p>单例模式的主要角色如下：</p><ul><li>单例类：包含一个实例且能自行创建这个实例的类。</li><li>访问类：使用单例的类。</li></ul><h3 id="2-单例模式的实现"><a href="#2-单例模式的实现" class="headerlink" title="2. 单例模式的实现"></a>2. 单例模式的实现</h3><h4 id="1-饿汉式"><a href="#1-饿汉式" class="headerlink" title="1. 饿汉式"></a>1. 饿汉式</h4><p>该模式的特点是类一旦加载就创建一个单例，保证在调用 getInstance 方法之前单例已经存在了。</p><pre><code>public class HungrySingleton {    private static final HungrySingleton instance = new HungrySingleton();    private HungrySingleton() {    }    public static HungrySingleton getInstance() {        return instance;    }}</code></pre><h4 id="2-懒汉式"><a href="#2-懒汉式" class="headerlink" title="2. 懒汉式"></a>2. 懒汉式</h4><p>该模式的特点是类加载时没有生成单例，只有当第一次调用 getlnstance 方法时才去创建这个单例。</p><pre><code>public class LazySingleton {    private static volatile LazySingleton instance = null;    private LazySingleton() {    }    public static LazySingleton getInstance() {        if (instance == null) {            synchronized(LazySingleton.class) {                if (instance == null) {                    instance = new LazySingleton();                }            }        }        return instance;    }}</code></pre><h4 id="3-IoDH"><a href="#3-IoDH" class="headerlink" title="3. IoDH"></a>3. IoDH</h4><p>在IoDH中，我们在单例类中增加一个静态(static)内部类，在该内部类中创建单例对象，再将该单例对象通过getInstance()方法返回给外部使用。通过使用IoDH，我们既可以实现延迟加载，又可以保证线程安全，不影响系统性能，不失为一种最好的Java语言单例模式实现方式。</p><pre><code>class Singleton {    private Singleton() {    }    private static class HolderClass {        private final static Singleton instance = new Singleton();    }    public static Singleton getInstance() {        return HolderClass.instance;    }}</code></pre><h2 id="五、单例模式实际应用"><a href="#五、单例模式实际应用" class="headerlink" title="五、单例模式实际应用"></a>五、单例模式实际应用</h2><h4 id="1-单例模式在JDK中的应用"><a href="#1-单例模式在JDK中的应用" class="headerlink" title="1. 单例模式在JDK中的应用"></a>1. 单例模式在JDK中的应用</h4><p>JDK 中 Runtime 类使用了单例模式，源码如下：</p><pre><code>public class Runtime {    private static Runtime currentRuntime = new Runtime();    public static Runtime getRuntime() {        return currentRuntime;    }    private Runtime() {    }}</code></pre><h4 id="2-单例模式在Spring中的应用"><a href="#2-单例模式在Spring中的应用" class="headerlink" title="2. 单例模式在Spring中的应用"></a>2. 单例模式在Spring中的应用</h4><p>Spring bean 默认是单例模式。</p><h4 id="3-单例模式在MyBatis中的应用"><a href="#3-单例模式在MyBatis中的应用" class="headerlink" title="3. 单例模式在MyBatis中的应用"></a>3. 单例模式在MyBatis中的应用</h4><p>在MyBatis中有两个地方用到单例模式，ErrorContext和LogFactory，其中ErrorContext是用在<strong>每个线程范围内</strong>的单例，用于记录该线程的执行环境错误信息，而LogFactory则是提供给<strong>整个MyBatis</strong>使用的日志工厂，用于获得针对项目配置好的日志对象。</p><p>ErrorContext源码如下：</p><pre><code>public class ErrorContext {    private static final ThreadLocal&lt;ErrorContext&gt; LOCAL = new ThreadLocal&lt;ErrorContext&gt;();    private ErrorContext() {    }    public static ErrorContext instance() {        ErrorContext context = LOCAL.get();        if (context == null) {            context = new ErrorContext();            LOCAL.set(context);        }        return context;    }}</code></pre><p>LogFactory源码如下：</p><pre><code>public final class LogFactory {    private static Constructor&lt;? extends Log&gt; logConstructor;    private LogFactory() {    }    public static Log getLog(Class&lt;?&gt; aClass) {        return getLog(aClass.getName());    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>美妙生活之自习室被夸奖</title>
      <link href="/2021/12/18/sheng-huo/mei-miao-sheng-huo-zhi-zi-xi-shi-bei-kua-jiang/"/>
      <url>/2021/12/18/sheng-huo/mei-miao-sheng-huo-zhi-zi-xi-shi-bei-kua-jiang/</url>
      
        <content type="html"><![CDATA[<p>在自习室写代码，旁边的小哥哥问”您这个是Python吗？”，我说”不是，是Java开发语言”。</p><p>他若有所思地点点头，竖起了大拇指，然后说编程是一项很需要掌握的技术。他介绍自己是做金融的，公司里面也有很多程序员，他很羡慕，说想学Python去分析数据。我鼓励他Python很容易入门，相信他一定能掌握。</p><p>临走的时候，我说如果有机会再碰到，我们可以一起交流一下。</p><p>生活就是这样，总能在某个时间，某个地点，遇到某个人，发生某些有趣的事！</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>性能优化</title>
      <link href="/2021/12/18/xing-neng-you-hua/xing-neng-you-hua/"/>
      <url>/2021/12/18/xing-neng-you-hua/xing-neng-you-hua/</url>
      
        <content type="html"><![CDATA[<h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>最近公司项目性能问题很多，在解决的过程中总结了一些性能优化的经验。</p><h3 id="定位慢接口-慢SQL"><a href="#定位慢接口-慢SQL" class="headerlink" title="定位慢接口/慢SQL"></a>定位慢接口/慢SQL</h3><ol><li>在代码中通过StopWatch打印代码段或接口执行时间；</li><li>通过公司自研工具Hippo Monitor-&gt;服务监控-&gt;调用链监控-&gt;输入接口名称查询耗时；</li><li>通过阿里巴巴开源的Java诊断工具arthas追踪各接口执行时间。</li></ol><h3 id="导致慢的原因及解决方案"><a href="#导致慢的原因及解决方案" class="headerlink" title="导致慢的原因及解决方案"></a>导致慢的原因及解决方案</h3><h4 id="一、粗粒度"><a href="#一、粗粒度" class="headerlink" title="一、粗粒度"></a>一、粗粒度</h4><h5 id="1-单线程处理大数据"><a href="#1-单线程处理大数据" class="headerlink" title="1. 单线程处理大数据"></a>1. 单线程处理大数据</h5><p>改完多线程处理。</p><h5 id="2-某个操作-方法执行次数太多"><a href="#2-某个操作-方法执行次数太多" class="headerlink" title="2. 某个操作/方法执行次数太多"></a>2. 某个操作/方法执行次数太多</h5><p>比如我们使用easy excel导入时，在一个for循环中使用poi的CellStyle.cloneStyleFrom方法拷贝单元格样式，耗时非常严重。</p><p>在for循环外面定义一个或几个变量保存拷贝过的样式，如果样式已存在，直接返回，不需要每次都拷贝。</p><h4 id="二、细粒度"><a href="#二、细粒度" class="headerlink" title="二、细粒度"></a>二、细粒度</h4><h5 id="1-慢SQL"><a href="#1-慢SQL" class="headerlink" title="1. 慢SQL"></a>1. 慢SQL</h5><ul><li>根据业务，优化SQL实现逻辑</li><li>让SQL尽可能走索引</li><li>修改SQL写法（需要一定经验或多次尝试）</li></ul>]]></content>
      
      
      <categories>
          
          <category> 性能优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>美妙生活之租房被套路</title>
      <link href="/2021/12/18/sheng-huo/mei-miao-sheng-huo-zhi-zu-fang-bei-tao-lu/"/>
      <url>/2021/12/18/sheng-huo/mei-miao-sheng-huo-zhi-zu-fang-bei-tao-lu/</url>
      
        <content type="html"><![CDATA[<h4 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h4><p>我和同事准备合租，前前后后找了很多地方，最后选中了一个小区，然后通过小区中介开始找房子，于是就有了下面被套路的经历。</p><h4 id="租房套路"><a href="#租房套路" class="headerlink" title="租房套路"></a>租房套路</h4><ol><li>中介根据你的身份以及你的预算，给你找1套或2套特别合适的房子，然后给你报个价钱，你可能会出低一点，即便超出底线，他也会答应你，帮你和房东去谈。</li><li>如果看得出你喜欢之前的房子，下次就会带你去看价格很贵或者同等价格但是不好的房子，这样你就会觉得最初的几套好。</li><li>如果你定了具体的某一套房子，会把你叫过去和房东聊，而且之前会交代你一些事情（包括让你先转押金，表现出你真的想租这套房，到时容易和房东谈妥价格等等），让你配合他。到了之后你和房东、中介一起交谈，不一会房东会出去接个电话或者打个电话（这个也是当初中介和房东商量好的），然后中介会说是之前有人也看过房子，而且价格更高，一般高出400-500吧，房东这会出去接电话，多半是因为这个事情。</li><li>接电话回来以后，房东一般会说要几个小时后才做决定，然后中介会直接挑明这个话题，问房东是不是要等上一个看房的人做决定，他们这样一配合，会让你觉得这个房子有点抢手。然后中介会让房东回去，再在你面前假装各种出谋划策，表现出为你争取这套房子的努力。</li><li>最后中介和你说，可不可以提高一下价格，因为房子很有可能租给别人，如果你提高了，那么你就上钩了。对于着急租房的人，这样的套路成功率很高！</li></ol><h4 id="小感悟"><a href="#小感悟" class="headerlink" title="小感悟"></a>小感悟</h4><p>这套做法最高明之处就是分别透漏给房东和租客有限的信息（更多时候是只透漏给租客有限的信息），然后给他们指出对自己有利的做法，双方为了自己，纷纷尽情表演，殊不知这一切都是中介导演的。</p><p>生活中很多时候就是这样，由于我们掌握的信息有限，再加上一些客观因素，比如急于做成某件事情，导致一时难以做出最清晰的决定。</p><p>希望以后的日子里，在做一些重大决定的时候，可以冷静一点，尽量搜集更多的信息，这样才能做出相对理智的决定。对于那些不太重要的决定，也不需要那么斤斤计较，毕竟太理智，生活就没有乐趣了。</p><p>租房子就是一个不重要的事情，被套路就被套路了，重要的是和谁一起被套路！[捂脸]</p><p>我的同事说“享受吧，被别人套，以后就会套人（肯定不会，哈哈），或防套”，“生活就是这样，防不胜防，关键是看代价有多大”。</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式概述</title>
      <link href="/2021/12/11/she-ji-mo-shi/she-ji-mo-shi-gai-shu/"/>
      <url>/2021/12/11/she-ji-mo-shi/she-ji-mo-shi-gai-shu/</url>
      
        <content type="html"><![CDATA[<h2 id="一、什么是设计模式"><a href="#一、什么是设计模式" class="headerlink" title="一、什么是设计模式"></a>一、什么是设计模式</h2><p>设计模式是指在软件设计中，被人反复使用的、经过分类编目的、代码设计经验的总结。<br>使用设计模式的目的是为了可重用代码，提高代码的可扩展性和可维护性。</p><h2 id="二、设计模式七大原则"><a href="#二、设计模式七大原则" class="headerlink" title="二、设计模式七大原则"></a>二、设计模式七大原则</h2><p>面向对象的设计模式有七大基本原则：</p><ul><li>开闭原则</li><li>单一职责原则</li><li>里氏替换原则</li><li>依赖倒置原则</li><li>接口隔离原则</li><li>迪米特原则/最少知识原则</li><li>合成/聚合复用原则</li></ul><h4 id="1-开闭原则"><a href="#1-开闭原则" class="headerlink" title="1. 开闭原则"></a>1. 开闭原则</h4><p>一个软件实体，如类、模块和函数应该<strong>对扩展开放，对修改关闭</strong>。模块应尽量在不修改原码的情况下进行扩展，防止引入新的错误。</p><h5 id="如何实现对扩展开放，对修改关闭"><a href="#如何实现对扩展开放，对修改关闭" class="headerlink" title="如何实现对扩展开放，对修改关闭"></a>如何实现对扩展开放，对修改关闭</h5><p>需要对系统进行抽象化设计，抽象可以基于抽象类或接口。</p><ol><li>通过接口或抽象类约束扩展，对扩展进行边界限定，不允许出现在抽象类或接口中不存在的public方法，也就是扩展必须添加具体实现而不是修改具体方法。</li><li>参数类型、引用对象尽量使用接口或抽象类，而不是实现类，这样就能尽量保证抽象层是稳定的。</li><li>一般抽象模块设计完成，不允许修改接口或者抽象方法的定义。</li></ol><h4 id="2-单一职责原则"><a href="#2-单一职责原则" class="headerlink" title="2. 单一职责原则"></a>2. 单一职责原则</h4><p><strong>一个类只负责一个功能领域中的相应职责。</strong> 职责太多会导致职责耦合在一起，一个职责的变化会影响其他职责。此原则的核心就是解耦和增强内聚性。</p><h4 id="3-里氏替换原则"><a href="#3-里氏替换原则" class="headerlink" title="3. 里氏替换原则"></a>3. 里氏替换原则</h4><p><strong>所有引用基类的地方必须能透明地使用其子类的对象。</strong> 里氏替换原则是对开闭原则的补充，开闭原则的关键步骤是抽象化，而基类与子类的继承关系就是抽象化的具体实现。</p><h4 id="4-依赖倒置原则"><a href="#4-依赖倒置原则" class="headerlink" title="4. 依赖倒置原则"></a>4. 依赖倒置原则</h4><p><strong>程序要依赖于抽象接口，不能依赖于具体实现。</strong></p><p>依赖倒置原则要求我们在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类，即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而不要用具体类来做这些事情。为了确保该原则的应用，一个具体类应当只实现接口或抽象类中声明过的方法，而不要给出多余的方法，否则将导致无法调到在子类中增加的新方法。在引入抽象层后，系统将具有很好的灵活性，在程序中尽量使用抽象层进行编程，而将具体类写在配置文件中，这样一来，如果系统行为发生变化，只需对抽象层进行扩展，并修改配置文件，而无需修改原系统的源代码，在不修改的情况下来扩展系统的功能，满足开闭原则。</p><p>在实现依赖倒置原则时，我们需要针对抽象层编程，而将具体类的对象通过依赖注入的方式注入到其他对象中，依赖注入是指当一个对象要与其他对象发生依赖关系时，通过抽象来注入所依赖的对象。常用的注入方式有构造注入、Set注入和接口注入。Spring IOC是此实现的典范。</p><h4 id="5-接口隔离原则"><a href="#5-接口隔离原则" class="headerlink" title="5. 接口隔离原则"></a>5. 接口隔离原则</h4><p>客户端不应该依赖它不需要的接口，<strong>类之间的依赖关系应该建立在最小的接口上</strong>。简单来说就是建立单一的接口，使接口尽量细化，同时接口中的方法尽量少。</p><h4 id="6-迪米特原则-最少知识原则"><a href="#6-迪米特原则-最少知识原则" class="headerlink" title="6. 迪米特原则/最少知识原则"></a>6. 迪米特原则/最少知识原则</h4><p><strong>一个软件实体应当尽可能少的与其他实体发生相互作用。</strong> 迪米特原则不希望类之间建立直接的联系，如果真的需要建立联系，也希望通过它的友元类（中间类或跳转类）来转达。</p><h4 id="7-合成-聚合复用原则"><a href="#7-合成-聚合复用原则" class="headerlink" title="7. 合成/聚合复用原则"></a>7. 合成/聚合复用原则</h4><p><strong>尽量使用合成/聚合，而不是继承达到复用的目的</strong>。继承是“白箱”复用，合成/聚合是“黑箱”复用。一般情况下，只有明确知道派生类和基类满足<code>IS A</code>的时候才选用继承，当满足<code>HAS A</code>或者不能判断的情况下应该选用合成/聚合。</p><h2 id="三、设计模式类型"><a href="#三、设计模式类型" class="headerlink" title="三、设计模式类型"></a>三、设计模式类型</h2><h4 id="1-创建型模式"><a href="#1-创建型模式" class="headerlink" title="1. 创建型模式"></a>1. 创建型模式</h4><p>创建型模式的主要关注点是”怎样创建对象”，它的主要特点是”将对象的创建和使用分离”。这样可以降低系统的耦合度，使用者不需要关注对象的创建细节，对象的创建由相关的工厂来完成。</p><p>创建型模式分为以下5种：</p><ol><li><strong>单例模式</strong><br>某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例。</li><li><strong>原型模式</strong><br>将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。</li><li><strong>工厂方法模式</strong><br>定义一个用于创建产品的接口，由子类决定生产什么产品。</li><li><strong>抽象工厂模式</strong><br>提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。</li><li><strong>建造者模式</strong><br>将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建他们，最后构建成该复杂对象。</li></ol><p>以上5种创建型模式，除了工厂方法模式属于类创建型模式，其他的全部属于对象创建型模式。</p><h4 id="2-结构型模式"><a href="#2-结构型模式" class="headerlink" title="2. 结构型模式"></a>2. 结构型模式</h4><p>结构型模式描述如何将类或对象按某种布局组成更大的结构。它分为类结构型模式和对象结构型模式，前者采用<strong>继承机制</strong>来组织接口和类，后者采用<strong>组合或聚合</strong>来组合对象。</p><p>由于组合关系或聚合关系比继承关系耦合度更低，所以对象结构型模式比类结构型模式具有更大的灵活性。</p><p>结构型模式分为以下7种：</p><ol><li><strong>代理模式</strong><br>为某个对象提供一种代理以控制对该对象的访问。即客户端通过代理间接访问该对象，从而限制、增强或修改该对象的一些特性。</li><li><strong>适配器模式</strong><br>将一个类的接口转换成客户希望的另一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。</li><li><strong>桥接模式</strong><br>将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现的，从而降低了抽象和实现这两个可变维度的耦合度。</li><li><strong>装饰模式</strong><br>动态地给对象增加一些职责，即增加额外的功能。</li><li><strong>外观模式</strong><br>为多个复杂的子系统提供一个一致的接口，使得这些子系统更容易被访问。</li><li><strong>享元模式</strong><br>运用共享技术来有效地支持大量细粒度对象的复用。</li><li><strong>组合模式</strong><br>将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。</li></ol><p>以上7种结构型模式，除了适配器模式分为类结构型模式和对象结构型模式两种，其他全部属于对象结构型模式。</p><h4 id="3-行为型模式"><a href="#3-行为型模式" class="headerlink" title="3. 行为型模式"></a>3. 行为型模式</h4><p>行为型模式用于描述程序在运行时复杂的流程控制，即描述多个类或对象之间怎样互相协作共同完成单个对象无法完成的任务，它涉及算法与对象间职责的分配。</p><p>行为型模式分为类行为模式和对象行为模式，前者采用继承机制在类间分派行为，后者采用组合或聚合在对象间分派行为。由于组合关系或聚合关系比继承关系耦合度低，所以对象行为模式比类行为模式有更大的灵活性。</p><p>行为型模式分为以下11种：</p><ol><li><strong>模板方法模式</strong><br>定义一个操作中的算法骨架，将算法的一些步骤延迟到子类中，使得子类在不改变该算法结构的情况下，重新定义该算法的某些特定步骤。</li><li><strong>策略模式</strong><br>定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。</li><li><strong>命令模式</strong><br>将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分开。</li><li><strong>职责链模式</strong><br>把请求从链中的一个对象传递到另一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。</li><li><strong>状态模式</strong><br>允许一个对象在其内部状态发生改变时改变其行为能力。</li><li><strong>观察者模式</strong><br>多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。</li><li><strong>中介者模式</strong><br>定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。</li><li><strong>迭代器模式</strong><br>提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。</li><li><strong>访问者模式</strong><br>在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。</li><li><strong>备忘录模式</strong><br>在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。</li><li><strong>解释器模式</strong><br>提供如何定义语言的文法，以及对语言句子的解释方法。</li></ol><p>以上11种行为型模式，除了模板方法模式和解释器模式是类行为模式，其他都是对象行为型模式。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建博客过程中遇到的问题</title>
      <link href="/2021/12/07/bo-ke/da-jian-bo-ke-guo-cheng-zhong-yu-dao-de-wen-ti/"/>
      <url>/2021/12/07/bo-ke/da-jian-bo-ke-guo-cheng-zhong-yu-dao-de-wen-ti/</url>
      
        <content type="html"><![CDATA[<h2 id="一、hexo-d-报错"><a href="#一、hexo-d-报错" class="headerlink" title="一、hexo d 报错"></a>一、hexo d 报错</h2><pre><code>fatal: unable to access &#39;https://github.com/huiminghu/huiminghu.github.io.git/&#39;: LibreSSL SSL_connect: SSL_ERROR_SYSCALL in connection to github.com:443</code></pre><p>将config.xml的repository url<br>由<code>https://github.com/huiminghu/huiminghu.github.io.git</code><br>改为<code>git@github.com:huiminghu/huiminghu.github.io.git</code>。</p><h2 id="二、执行n-latest安装node最新版本时报错"><a href="#二、执行n-latest安装node最新版本时报错" class="headerlink" title="二、执行n latest安装node最新版本时报错"></a>二、执行n latest安装node最新版本时报错</h2><pre><code>Error: sudo required (or change ownership, or define N_PREFIX)</code></pre><p>答案原地址：<a href="https://stackoverflow.com/questions/61677951/why-n-throws-error-error-sudo-required-or-change-ownership-or-define-n-prefi" target="_blank" rel="noopener">stackoverflow</a></p><ol><li>You would need to change where n stores node versions ownership<pre><code>sudo mkdir -p /usr/local/n &amp;&amp; sudo chown -R $(whoami) /usr/local/n/</code></pre></li><li>Add yourself to the group and grant write permission<pre><code>sudo dseditgroup -o edit -a $(whoami) -t user wheel</code></pre></li><li>Allow wheel members writing permission on that folder<pre><code>sudo chmod -R g+w /usr/local/n/</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>终于有自己的博客啦</title>
      <link href="/2021/12/05/bo-ke/zhong-yu-you-zi-ji-de-bo-ke-la/"/>
      <url>/2021/12/05/bo-ke/zhong-yu-you-zi-ji-de-bo-ke-la/</url>
      
        <content type="html"><![CDATA[<p>  几年前开始写博客，试过在知乎、简书等公共博客平台写作，但是上面的排版实在不符合自己的”审美”，于是开始折腾自己搭建，试过halo、mblog这些开源的博客框架，也在其基础上做了改进，但是始终达不到自己的要求。而后转战hexo + github pages，刚开始搭建出来，觉得这页面丑爆了，于是在网上搜索是否有修改样式的教程，很幸运看到了韦阳老师开源的hexo-theme-sungod，看到了自己真正喜欢的博客的样子，于是立马star&amp;fork了这个项目，在此基础上做了简单修改，就有了我现在博客的样子。</p><p>  以后我要在这个博客上写下自己的点点滴滴，这个才是真正意义上属于自己的博客！</p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
